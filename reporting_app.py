import sys
import warnings
# Filter warnings generated by certain selenium/bs4 interactions
warnings.filterwarnings("ignore", category=UserWarning)
warnings.filterwarnings("ignore", category=DeprecationWarning)

# PyQt Imports (using PyQt5 for the app/thread structure)
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QLabel, QLineEdit, QPushButton, QStackedWidget, QGraphicsView,
    QGraphicsScene, QMessageBox
)
from PyQt5.QtCore import Qt, QPointF, QRectF, QThread, pyqtSignal, QTimer
from PyQt5.QtGui import (
    QPen, QBrush, QColor, QPolygonF, QFont, QPainter, QPainterPath, QResizeEvent
)

# Core Imports
from seleniumbase import SB
import time
import random
from datetime import datetime
from urllib.parse import urlsplit
from bs4 import BeautifulSoup
from collections import defaultdict
import re
# Removed: import json, import csv

# ==============================================================================
# 1. DATA PARSING & LOGIC (BeautifulSoup Pipeline)
# ==============================================================================

SHIFT_TIMES = {
    "day":   ("8:00 AM",  "2:40 PM"),
    "swing": ("3:00 PM", "11:20 PM"),
}

USERNAME_RE = re.compile(r"^[A-Za-z][A-Za-z0-9]*$")
TIMESTAMP_RE = re.compile(
    r"\d{1,2}/\d{1,2}/\d{4}\s+\d{1,2}:\d{2}:\d{2}\s+[AP]M"
)

def parse_ts(ts):
    return datetime.strptime(ts, "%m/%d/%Y %I:%M:%S %p")

def get_shift(ts):
    """Determines the shift based on the timestamp."""
    try:
        ts_dt = parse_ts(ts)
        t = ts_dt.time()
    except ValueError:
        return None

    for shift, (start_str, end_str) in SHIFT_TIMES.items():
        start_t = datetime.strptime(start_str, "%I:%M %p").time()
        end_t = datetime.strptime(end_str, "%I:%M %p").time()

        if start_t <= end_t:
            if start_t <= t <= end_t:
                return shift
        else:
            if start_t <= t or t <= end_t:
                return shift
    return None

def is_task_list(text):
    return bool(re.match(r"(MQI-\d+)|(DA-\d+.*MQI-\d+)", text))

def is_timestamp(text):
    return bool(TIMESTAMP_RE.fullmatch(text))

def extract(html):
    """Extracts raw data rows from the SSRS report HTML using BS4."""
    soup = BeautifulSoup(html, "html.parser")
    # Find the report content div
    report = soup.find("div", id=lambda x: x and "oReportDiv" in x)
    
    if not report:
        report = soup.find("div", id=re.compile(r"ReportViewerControl_ctl09_ReportArea_ReportViewerControl_ctl09_ReportArea"))
        if not report:
             raise RuntimeError("âŒ Report content div not found in HTML (oReportDiv or ReportArea missing).")

    rows = []
    state = {
        "task_list": None,
        "employee": None,
    }

    for tr in report.find_all("tr"):
        tds = tr.find_all("td", recursive=False)
        if not tds:
            continue

        texts = [td.get_text(strip=True) for td in tds]

        txn_date = next((t for t in texts if is_timestamp(t)), None)
        if not txn_date:
            continue

        # ---- Resolve task list + employee (rowspan safe) ----
        seen_pass = False
        for t in texts:
            if t in ("PASS", "FAIL"):
                seen_pass = True
                continue

            if is_task_list(t):
                state["task_list"] = t
                continue

            if (
                not seen_pass
                and USERNAME_RE.fullmatch(t)
            ):
                state["employee"] = t

        # ---- Task item + status are adjacent ----
        task_item = None
        status = None
        for i in range(len(texts) - 1):
            if texts[i + 1] in ("PASS", "FAIL"):
                task_item = texts[i]
                status = texts[i + 1]
                break

        if status != "PASS":
            continue

        if not state["task_list"] or not state["employee"]:
            continue

        rows.append({
            "task_list": state["task_list"],
            "employee": state["employee"],
            "task_item": task_item,
            "txn_date": txn_date,
        })

    return rows

def organize(rows):
    """Groups the extracted rows by task list and shift, preparing for the GUI."""
    data = defaultdict(lambda: {
        "day": {"employee": "", "employees": set(), "tasks": set()},
        "swing": {"employee": "", "employees": set(), "tasks": set()}
    })

    for r in rows:
        shift = get_shift(r["txn_date"])
        if not shift: continue

        entry = data[r["task_list"]][shift]

        if not entry["employee"]:
            entry["employee"] = r["employee"]
        entry["employees"].add(r["employee"])
        entry["tasks"].add(r["task_item"])

    result = []
    for task_list, shifts in sorted(data.items()):
        out = {task_list: {}}
        for s in ("day", "swing"):
            out[task_list][s] = {
                "employee": shifts[s]["employee"],
                # Convert set back to list for JSON/PyQt signal transfer safety
                "task_completed": list(sorted(shifts[s]["tasks"])), 
                "total_passed": len(shifts[s]["tasks"]),
            }
        result.append(out)

    return result

# ==============================================================================
# 2. SELENIUM THREAD (Data Getter and Refresh Loop)
# ==============================================================================

REPORT_URL = "https://reporting.penumbrainc.com/Reports/report/MES%20General/DHR%20Report%20-%20Mfg"

def switch_into_report_iframe(sb, timeout=30):
    """Switches the Selenium context to the main report iframe."""
    sb.switch_to_default_content()
    try:
        sb.wait_for_element('iframe', timeout=timeout)
    except:
        return False

    selectors = [
        'iframe[id^="ReportViewerControl"]',
        'iframe[name^="ReportViewerControl"]',
        'iframe#ReportViewerControl_IFrame',
        "iframe",
    ]

    for sel in selectors:
        if sb.is_element_present(sel):
            try:
                sb.switch_to_frame(sel)
                if sb.is_element_present('input[name^="ReportViewerControl$ctl04"]'):
                    return True
            except:
                pass
            sb.switch_to_default_content()

    return False


class DHRMonitorThread(QThread):
    # Signals to communicate back to the GUI
    status_update = pyqtSignal(str)
    monitoring_stopped = pyqtSignal()
    # Signal to send the organized list of dicts to the GUI
    data_fetched = pyqtSignal(list)
    
    def __init__(self, container_num, username, password, parent=None):
        super().__init__(parent)
        self.container_num = container_num
        self.username = username
        self.password = password
        self._is_running = True

    def stop(self):
        self._is_running = False
        self.wait(200) 

    def run(self):
        sb = None
        try:
            # Set headless=False so the user sees the browser
            sb = SB(browser="chrome", headless=False) 
                
            AUTH_URL = (
                f"https://{self.username}:{self.password}@"
                f"{urlsplit(REPORT_URL).netloc}"
                f"{urlsplit(REPORT_URL).path}"
            )

            self.status_update.emit("Opening report URL and attempting login...")
            sb.open(AUTH_URL)
            time.sleep(3)
            sb.open(REPORT_URL)
            time.sleep(5)

            # --- 1. Initial Report Setup ---
            if not switch_into_report_iframe(sb):
                self.status_update.emit("ERROR: Could not locate report iframe. Check URL/Permissions.")
                return

            self.status_update.emit(f"Entering container number: {self.container_num}")
            sb.wait_for_element('input[name="ReportViewerControl$ctl04$ctl03$txtValue"]')
            sb.type('input[name="ReportViewerControl$ctl04$ctl03$txtValue"]', self.container_num)
            time.sleep(1)

            self.status_update.emit("Setting date filter to 'Today'.")
            sb.wait_for_element('select[name="ReportViewerControl$ctl04$ctl09$ddValue"]')
            sb.select_option_by_text(
                'select[name="ReportViewerControl$ctl04$ctl09$ddValue"]',
                "Today"
            )
            time.sleep(1)

            if not switch_into_report_iframe(sb):
                self.status_update.emit("ERROR: iframe missing after date selection.")
                return

            self.status_update.emit("Viewing report for the first time...")
            sb.wait_for_element('input[id="ReportViewerControl_ctl04_ctl00"]')
            sb.click('input[id="ReportViewerControl_ctl04_ctl00"]')
            time.sleep(5)

            if not switch_into_report_iframe(sb):
                self.status_update.emit("ERROR: iframe missing after View Report. This step is critical.")
                return
            
            # Wait for the report to confirm content load
            sb.wait_for_element('//div[contains(text(), "DHR Report")]', timeout=60)
            
            self.status_update.emit("Report loaded. Starting monitoring loop.")
            
            # --- 2. Monitoring Loop: get html -> parse -> render -> refresh ---
            while self._is_running:
                try:
                    # a. Get HTML (needs to be on default content)
                    sb.switch_to_default_content()
                    html_content = sb.get_page_source()
                    
                    # b. Parse data with BS4
                    rows = extract(html_content)
                    organized_data = organize(rows)
                    
                    # c. Send data to PyQt for rendering
                    self.data_fetched.emit(organized_data)
                    self.status_update.emit(f"Data fetched and processed: {len(organized_data)} task lists found.")

                    # d. Determine sleep time
                    random_delay_seconds = random.randint(3, 15)
                    for i in range(random_delay_seconds):
                        if not self._is_running: break
                        time.sleep(1)
                    
                    if not self._is_running: break

                    # e. Refresh the report (needs to be on default content)
                    self.status_update.emit(f"Refreshing report... (Next check in {random_delay_seconds} seconds)")
                    
                    sb.switch_to_default_content() 
                    sb.wait_for_element("span.glyphui-refresh")
                    sb.click("span.glyphui-refresh")
                    time.sleep(5) 

                    # f. Wait for the report to reload before the next loop iteration
                    if not switch_into_report_iframe(sb):
                        self.status_update.emit("ERROR: Lost iframe after refresh. Exiting monitoring loop.")
                        break

                except RuntimeError as re:
                    self.status_update.emit(f"HTML/BS4 Extraction Error: {re}")
                    time.sleep(5)
                
                except Exception as e:
                    self.status_update.emit(f"MONITORING LOOP ERROR: {e}")
                    time.sleep(10)
            
        except Exception as e:
            self.status_update.emit(f"MONITORING CRASHED: {e}")
            
        finally:
            if sb:
                sb.quit() 
            self.monitoring_stopped.emit()

# ==============================================================================
# 3. PYQT VISUALIZATION (Data Visualizer)
# ==============================================================================

# --- Design Constants ---
COLOR_BG = QColor("#2F2F2F")       
COLOR_LINE = QColor("#3272AE")     
COLOR_NODE_Border = QColor("#e0e0e0") 
COLOR_TEXT_HEADER = QColor("#ffffff")
COLOR_TEXT_USER = QColor("#7b7766")   
COLOR_TEXT_TASK = QColor("#ffffff")

COLOR_RED = QColor("#C53F3F")      
COLOR_GREEN = QColor("#529850")    
COLOR_ORANGE = QColor("#d25b35")   
COLOR_BLACK = QColor("#000000")    

# --- User-Specified Button Colors ---
COLOR_START_MONITORING_ENABLED = QColor("#4c8e35") 
COLOR_STOP_MONITORING = QColor("#a63c3a")         
COLOR_BUTTON_DISABLED = QColor("#d0d0d0")         

FONT_HEADER = QFont("Arial", 10, QFont.Weight.Bold)
FONT_USER = QFont("Arial", 22, QFont.Weight.Bold)
FONT_TASK = QFont("Arial", 11, QFont.Weight.Bold)

# --- Logical Coordinates and Mapping ---
STATION_CONFIG = {
    "Shaving":     {"pos": (250, 200), "shape": "circle", "layout": "top", "tasks": ["Workstation Setup", "Verify Open Documents", "Perform Process"]},
    "Lamination":  {"pos": (550, 200), "shape": "circle", "layout": "top", "tasks": ["Workstation Setup", "Equipment Setup", "Perform Process"]},
    "Prep":        {"pos": (850, 200), "shape": "circle", "layout": "top", "tasks": ["Workstation Setup", "Equipment Setup", "Issue Floor Stock", "Material Verification", "Perform Process"]},
    "DDT":         {"pos": (1150, 200),"shape": "circle", "layout": "top", "tasks": ["Workstation Setup", "Equipment Setup", "Issue Floor Stock", "Material Verification", "Perform Process"]},
    "Wireloading": {"pos": (250, 500), "shape": "circle", "layout": "left","tasks": ["Workstation Setup", "Equipment Setup", "Material Verification", "Perform Process"]},
    "Crimp":       {"pos": (250, 800), "shape": "circle", "layout": "bottom", "tasks": ["Workstation Setup", "Equipment Setup", "Material Verification", "Perform Process"]},
    "Bump":        {"pos": (550, 800), "shape": "circle", "layout": "bottom", "tasks": ["Workstation Setup", "Equipment Setup", "Material Verification", "Perform Process"]},
    "QC":          {"pos": (850, 800), "shape": "triangle","layout": "bottom", "tasks": ["Workstation Setup", "Verify LHC and Docs", "Perform Process"]},
    "Shipping":    {"pos": (1150, 800),"shape": "square",  "layout": "bottom", "tasks": ["Workstation Setup", "Verify Open Documents", "Perform Process"]}
}

STATION_MAPPING = {
    "DA-1181_MQI-24751": "Wireloading", 
    "MQI-24747_03": "Prep",
    "MQI-24748_03": "DDT",
    "MQI-24749_04": "Lamination",
    "MQI-24750_03": "Shaving",
    "MQI-24752_04": "Crimp",
    "MQI-24753_03": "Bump",
    "MQI-24803_03": "Shipping",
    "MQI-2565_QC_Insp_05": "QC"
}

def update_timestamp(last_check_time: datetime) -> str:
    """Formats the time string as: MM/DD/YYYY HH:SS AM/PM."""
    return last_check_time.strftime("%m/%d/%Y %I:%M:%S %p")

class StationNode:
    """Represents a single station's visual element and data."""
    def __init__(self, name, config, scene):
        self.name = name
        self.config = config
        self.scene = scene
        self.x, self.y = config["pos"]
        self.shape = config["shape"]
        self.layout_type = config["layout"]
        self.node_size = 70
        self.status = "no_employee" 
        self.employee = "Waiting..."
        self.tasks = {task: False for task in config["tasks"]}
        self.items = []
        self.create_graphics()
    
    def clear_graphics(self):
        for item in self.items:
            if item.scene():
                self.scene.removeItem(item)
        self.items = []

    def create_graphics(self):
        self.clear_graphics()

        border_pen = QPen(COLOR_NODE_Border, 5)
        fill_color = COLOR_BLACK
        if self.status == "logged_in": fill_color = COLOR_RED
        elif self.status == "in_progress": fill_color = COLOR_ORANGE
        elif self.status == "completed": fill_color = COLOR_GREEN

        shape_brush = QBrush(fill_color)
        
        if self.shape == "circle":
            shape_item = self.scene.addEllipse(self.x - self.node_size/2, self.y - self.node_size/2, self.node_size, self.node_size, border_pen, shape_brush)
        elif self.shape == "square":
            shape_item = self.scene.addRect(self.x - self.node_size/2, self.y - self.node_size/2, self.node_size, self.node_size, border_pen, shape_brush)
        elif self.shape == "triangle":
            h = self.node_size
            points = QPolygonF([QPointF(self.x, self.y - h/1.5), QPointF(self.x - h/1.5, self.y + h/2), QPointF(self.x + h/1.5, self.y + h/2)])
            shape_item = self.scene.addPolygon(points, border_pen, shape_brush)
        
        shape_item.setZValue(2)
        self.items.append(shape_item)

        text_group_items = []
        header_txt = self.scene.addText(f"{self.name}:")
        header_txt.setDefaultTextColor(COLOR_TEXT_HEADER)
        header_txt.setFont(FONT_HEADER)
        text_group_items.append(header_txt)
        
        user_txt = self.scene.addText(self.employee)
        user_txt.setDefaultTextColor(COLOR_TEXT_USER)
        user_txt.setFont(FONT_USER)
        user_txt.setPos(0, header_txt.boundingRect().height() - 5)
        text_group_items.append(user_txt)
        
        current_y = user_txt.pos().y() + user_txt.boundingRect().height() + 5
        
        for task_name, is_done in self.tasks.items():
            dot_color = COLOR_GREEN if is_done else COLOR_RED
            dot = self.scene.addEllipse(0, 0, 16, 16, QPen(Qt.NoPen), QBrush(dot_color))
            dot.setPos(0, current_y + 4)
            text_group_items.append(dot)
            
            t_txt = self.scene.addText(task_name)
            t_txt.setDefaultTextColor(COLOR_TEXT_TASK)
            t_txt.setFont(FONT_TASK)
            t_txt.setPos(25, current_y)
            text_group_items.append(t_txt)
            current_y += 25

        self.items.extend(text_group_items)

        max_width = max(item.boundingRect().width() + item.x() for item in text_group_items)
        text_block_height = current_y
        vertical_offset_to_center = self.y - (text_block_height / 2)

        if self.layout_type == "top":
            start_x = self.x - max_width / 2
            SPACING = 20
            start_y = self.y - self.node_size/2 - SPACING - text_block_height 
        elif self.layout_type == "bottom":
            start_x = self.x - max_width / 2
            SPACING = 20
            start_y = self.y + self.node_size/2 + SPACING
        elif self.layout_type == "left":
            SPACING = 30 
            start_x = self.x - self.node_size/2 - SPACING - max_width 
            start_y = vertical_offset_to_center 

        for item in text_group_items:
            if item is header_txt or item is user_txt:
                offset_x = (max_width - item.boundingRect().width()) / 2 if self.layout_type in ("top", "bottom") else 0
                item.setPos(start_x + offset_x, start_y + item.y())
            else:
                item.setPos(start_x + item.x(), start_y + item.y())

    def update_status(self, employee, tasks_completed):
        """Updates the node's data and triggers a redraw."""
        self.employee = employee if employee else "Waiting..."
        for task in self.tasks: self.tasks[task] = task in tasks_completed
        
        if not employee: self.status = "no_employee"
        elif all(self.tasks.values()): self.status = "completed"
        elif any(self.tasks.values()): self.status = "in_progress"
        else: self.status = "logged_in"
        self.create_graphics()


class ResizableGraphicsView(QGraphicsView):
    """Custom view that handles resize events to refit the scene"""
    def resizeEvent(self, event: QResizeEvent):
        super().resizeEvent(event)
        if self.scene():
            self.fitInView(self.scene().sceneRect(), Qt.KeepAspectRatio)

class MonitoringScreen(QWidget):
    def __init__(self, container, parent=None):
        super().__init__(parent)
        self.container = container
        self.stations = {}
        self.last_check_time = datetime.now() 
        self.thread = None 
        self.setup_ui()
    
    def setup_ui(self):
        layout = QVBoxLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        # -- Header --
        header_widget = QWidget()
        header_widget.setStyleSheet(f"background-color: {COLOR_BG.name()}; padding: 10px;")
        header_layout = QHBoxLayout(header_widget)
        header_layout.setContentsMargins(10, 0, 10, 0)
        
        self.container_label = QLabel(f"Container: {self.container}")
        self.container_label.setStyleSheet("color: white; font-size: 18px; font-weight: bold;")
        self.last_checked_label = QLabel("Last Checked: -- | Status: Ready")
        self.last_checked_label.setStyleSheet("color: #aaaaaa; font-size: 14px;")
        
        header_layout.addWidget(self.container_label)
        header_layout.addStretch()
        header_layout.addWidget(self.last_checked_label)
        
        layout.addWidget(header_widget)
        
        # -- Graphics View --
        self.scene = QGraphicsScene()
        self.scene.setBackgroundBrush(QBrush(COLOR_BG))
        self.scene.setSceneRect(0, 0, 1400, 1000)
        self.view = ResizableGraphicsView(self.scene)
        self.view.setRenderHint(QPainter.Antialiasing)
        self.view.setStyleSheet("border: none; background-color: #2F2F2F;")
        self.view.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.view.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        
        self.draw_workflow_lines()
        
        for name, config in STATION_CONFIG.items():
            self.stations[name] = StationNode(name, config, self.scene)

        bounds = self.scene.itemsBoundingRect()
        buffer = 20
        self.scene.setSceneRect(bounds.adjusted(-buffer, -buffer, buffer, buffer))

        layout.addWidget(self.view)
        
        # -- Footer Button (UPDATED COLOR) -- 
        footer_widget = QWidget()
        footer_widget.setStyleSheet(f"background-color: {COLOR_BG.name()};")
        footer_layout = QHBoxLayout(footer_widget)
        footer_layout.setContentsMargins(20, 10, 20, 20)
        footer_layout.addStretch()
        self.stop_button = QPushButton("Stop Monitoring")
        self.stop_button.setCursor(Qt.PointingHandCursor)
        self.stop_button.setStyleSheet(f"""
            QPushButton {{
                background-color: {COLOR_STOP_MONITORING.name()};
                color: white;
                font-weight: bold;
                font-size: 16px;
                padding: 12px 40px;
                border-radius: 4px;
            }}
            QPushButton:hover {{ background-color: {COLOR_STOP_MONITORING.darker(120).name()}; }}
        """)
        footer_layout.addWidget(self.stop_button)
        footer_layout.addStretch()
        layout.addWidget(footer_widget)
        
        self.setLayout(layout)

    def showEvent(self, event):
        super().showEvent(event)
        QTimer.singleShot(50, lambda: self.view.fitInView(self.scene.sceneRect(), Qt.KeepAspectRatio))

    def draw_workflow_lines(self):
        path = QPainterPath()
        s = STATION_CONFIG
        
        path.moveTo(s["Shaving"]["pos"][0], s["Shaving"]["pos"][1])
        path.lineTo(s["Lamination"]["pos"][0], s["Lamination"]["pos"][1])
        path.lineTo(s["Prep"]["pos"][0], s["Prep"]["pos"][1])
        path.lineTo(s["DDT"]["pos"][0], s["DDT"]["pos"][1])
        path.moveTo(s["Shaving"]["pos"][0], s["Shaving"]["pos"][1])
        path.lineTo(s["Wireloading"]["pos"][0], s["Wireloading"]["pos"][1])
        path.lineTo(s["Crimp"]["pos"][0], s["Crimp"]["pos"][1])
        path.moveTo(s["Crimp"]["pos"][0], s["Crimp"]["pos"][1])
        path.lineTo(s["Bump"]["pos"][0], s["Bump"]["pos"][1])
        path.lineTo(s["QC"]["pos"][0], s["QC"]["pos"][1])
        path.lineTo(s["Shipping"]["pos"][0], s["Shipping"]["pos"][1])
        
        pen = QPen(COLOR_LINE, 20)
        pen.setCapStyle(Qt.RoundCap)
        pen.setJoinStyle(Qt.RoundJoin)
        path_item = self.scene.addPath(path, pen)
        path_item.setZValue(0)

    def start_monitoring(self, username, password):
        """Initializes and starts the Selenium thread."""
        self.thread = DHRMonitorThread(self.container, username, password)
        self.thread.status_update.connect(self.update_status_label)
        self.thread.monitoring_stopped.connect(self.monitoring_finished)
        self.thread.data_fetched.connect(self.update_stations_from_data) 
        self.thread.start()

    def update_status_label(self, status):
        """Receives status updates from the monitoring thread."""
        self.last_check_time = datetime.now()
        self.last_checked_label.setText(f"Last Checked: {update_timestamp(self.last_check_time)} | Status: {status}")

    def update_stations_from_data(self, organized_data):
        """
        Receives the processed list of dictionaries from the thread 
        and updates the visual nodes for the 'swing' shift.
        """
        self.last_checked_label.setStyleSheet("color: #ffffff; font-size: 14px;") 
        QTimer.singleShot(2000, lambda: self.last_checked_label.setStyleSheet("color: #aaaaaa; font-size: 14px;")) 
        
        # Reset stations to default before applying new data
        for station in self.stations.values():
             station.update_status("", [])

        # Apply new data
        for container_dict in organized_data:
            container_id = list(container_dict.keys())[0] 
            container_data = container_dict[container_id]
            
            shift_data = container_data.get("swing", {})
            employee = shift_data.get("employee", "")
            tasks_completed = shift_data.get("task_completed", [])
            
            station_name = STATION_MAPPING.get(container_id)
            
            if station_name and station_name in self.stations:
                self.stations[station_name].update_status(employee, tasks_completed)
        
        # Adjust view
        bounds = self.scene.itemsBoundingRect()
        buffer = 20
        self.scene.setSceneRect(bounds.adjusted(-buffer, -buffer, buffer, buffer))
        self.view.fitInView(self.scene.sceneRect(), Qt.KeepAspectRatio)

    def monitoring_finished(self):
        """Handles cleanup when the thread exits."""
        self.update_status_label("Monitoring stopped or crashed. Restart required.")
        self.stop_button.setText("Restart Monitoring")
        self.thread = None


class LoginScreen(QWidget):
    """Initial screen for credentials and container ID."""
    def __init__(self):
        super().__init__()
        layout = QVBoxLayout()
        layout.setAlignment(Qt.AlignCenter)
        layout.setSpacing(15)
        
        l1 = QLabel("Container:")
        l1.setStyleSheet("color: white; font-weight: bold; font-size: 16px;")
        self.entry_container = QLineEdit()
        self.entry_container.setPlaceholderText("Enter Container ID (e.g., C-999)")
        self.apply_entry_style(self.entry_container)
        
        l2 = QLabel("Username:")
        l2.setStyleSheet("color: white; font-weight: bold; font-size: 16px; margin-top: 10px;")
        self.entry_user = QLineEdit()
        self.entry_user.setPlaceholderText("Enter your Windows/Domain username")
        self.apply_entry_style(self.entry_user)
        
        l3 = QLabel("Password:")
        l3.setStyleSheet("color: white; font-weight: bold; font-size: 16px; margin-top: 10px;")
        self.entry_pass = QLineEdit()
        self.entry_pass.setEchoMode(QLineEdit.Password)
        self.entry_pass.setPlaceholderText("Enter your Windows/Domain password")
        self.apply_entry_style(self.entry_pass)
        
        self.btn_start = QPushButton("Start Monitoring")
        self.btn_start.setCursor(Qt.PointingHandCursor)
        
        # --- NEW: Connect signals to update button state ---
        self.entry_container.textChanged.connect(self.update_button_state)
        self.entry_user.textChanged.connect(self.update_button_state)
        self.entry_pass.textChanged.connect(self.update_button_state)
        
        self.update_button_state() # Initial call to set the disabled state

        layout.addWidget(l1)
        layout.addWidget(self.entry_container)
        layout.addWidget(l2)
        layout.addWidget(self.entry_user)
        layout.addWidget(l3)
        layout.addWidget(self.entry_pass)
        layout.addWidget(self.btn_start)
        self.setLayout(layout)

    def apply_entry_style(self, widget):
        widget.setFixedWidth(400)
        # --- UPDATED: Added 'color: black;' for input text ---
        widget.setStyleSheet("QLineEdit { color: black; padding: 10px; font-size: 14px; background-color: #e0e0e0; border-radius: 4px; border: none; }")

    def update_button_state(self):
        """
        Implements the logic: Button is enabled only if Container, User, AND Password fields are non-empty.
        Also applies the required color and style.
        """
        container_filled = bool(self.entry_container.text().strip())
        user_filled = bool(self.entry_user.text().strip())
        password_filled = bool(self.entry_pass.text()) # Password can contain spaces, check for any content
        
        is_valid = container_filled and user_filled and password_filled
        self.btn_start.setEnabled(is_valid)
        
        if is_valid:
            # Enabled: Use the requested start color
            style = f"""
                QPushButton {{
                    background-color: {COLOR_START_MONITORING_ENABLED.name()};
                    color: white;
                    padding: 15px 50px;
                    font-size: 18px;
                    font-weight: bold;
                    border-radius: 4px;
                    margin-top: 30px;
                }}
                QPushButton:hover {{ background-color: {COLOR_START_MONITORING_ENABLED.darker(120).name()}; }}
            """
        else:
            # Disabled: Use the standard disabled color
            style = f"""
                QPushButton {{
                    background-color: {COLOR_BUTTON_DISABLED.name()};
                    color: black;
                    padding: 15px 50px;
                    font-size: 18px;
                    font-weight: bold;
                    border-radius: 4px;
                    margin-top: 30px;
                }}
            """
        self.btn_start.setStyleSheet(style)


class MainWindow(QMainWindow):
    """Main application window controlling screen switching."""
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Manufacturing DHR Process Monitor")
        self.setStyleSheet(f"background-color: {COLOR_BG.name()};")
        self.resize(1200, 800)
        
        self.stack = QStackedWidget()
        self.setCentralWidget(self.stack)
        
        self.login = LoginScreen()
        self.login.btn_start.clicked.connect(self.go_to_monitor)
        self.stack.addWidget(self.login)
        
        self.monitor = None

    def go_to_monitor(self):
        # --- ENFORCED CHECK ---
        container_id = self.login.entry_container.text().strip()
        username = self.login.entry_user.text().strip()
        password = self.login.entry_pass.text()

        if not container_id or not username or not password:
            QMessageBox.warning(self, "Input Required", "Please enter Container, Username, and Password.")
            return

        if self.monitor is not None:
            if hasattr(self.monitor, 'thread') and self.monitor.thread:
                self.monitor.thread.stop()
            self.stack.removeWidget(self.monitor)
            self.monitor.deleteLater()
        
        self.monitor = MonitoringScreen(container_id)
        self.monitor.stop_button.clicked.connect(self.go_to_login)
        
        self.monitor.start_monitoring(username, password) 
        
        self.stack.addWidget(self.monitor)
        self.stack.setCurrentWidget(self.monitor)
        
    def go_to_login(self):
        if hasattr(self.monitor, 'thread') and self.monitor.thread:
            self.monitor.thread.stop()
        
        self.stack.setCurrentWidget(self.login)
        if self.monitor is not None:
            self.stack.removeWidget(self.monitor)
            self.monitor.deleteLater()
            self.monitor = None
        
        # Clear fields upon returning to login
        self.login.entry_pass.clear()
        self.login.entry_user.clear() 
        # Keep container ID filled for convenience, but clear the others.
        self.login.update_button_state() # Update button style to disabled


    def closeEvent(self, event):
        """Ensure the Selenium thread is stopped when the main window closes."""
        if self.monitor is not None and hasattr(self.monitor, 'thread') and self.monitor.thread:
            self.monitor.thread.stop()
        super().closeEvent(event)


if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec())